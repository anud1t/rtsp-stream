#!/bin/bash

# Script to stream a video file or camera to the local subnet using mediamtx and ffmpeg

# --- Configuration ---
DEFAULT_STREAM_NAME="mystream"
MEDIAMTX_RTSP_PORT="8554"
FFMPEG_LOG_LEVEL="error" # "info" or "debug" for more verbose ffmpeg output
MEDIAMTX_CONFIG_FILE="mediamtx.yml"
DEFAULT_CAMERA_RESOLUTION="640x480"
DEFAULT_CAMERA_FRAMERATE="30"

# --- Global Variables ---
ffmpeg_pid=""
mediamtx_pid=""
created_default_config=false
SOURCE_TYPE=""
INPUT_PATH=""
STREAM_NAME=""
CAMERA_RESOLUTION=""
CAMERA_FRAMERATE=""

# --- Helper Functions ---
print_error() {
    echo "Error: $1" >&2
}

print_warning() {
    echo "Warning: $1" >&2
}

print_info() {
    echo "Info: $1"
}

cleanup() {
    echo ""
    print_info "Initiating cleanup..."

    if [ -n "$ffmpeg_pid" ] && ps -p "$ffmpeg_pid" > /dev/null; then
        print_info "Stopping ffmpeg (PID: $ffmpeg_pid)..."
        kill "$ffmpeg_pid"
        wait "$ffmpeg_pid" 2>/dev/null
    fi

    if [ -n "$mediamtx_pid" ] && ps -p "$mediamtx_pid" > /dev/null; then
        print_info "Stopping mediamtx (PID: $mediamtx_pid)..."
        kill "$mediamtx_pid"
        wait "$mediamtx_pid" 2>/dev/null
    fi

    if [ "$created_default_config" = true ] && [ -f "$MEDIAMTX_CONFIG_FILE" ]; then
        if grep -q "paths:" "$MEDIAMTX_CONFIG_FILE" && grep -q "  all: {} # Auto-generated by script" "$MEDIAMTX_CONFIG_FILE"; then
            print_info "Removing auto-generated $MEDIAMTX_CONFIG_FILE..."
            rm "$MEDIAMTX_CONFIG_FILE"
        fi
    fi

    print_info "Cleanup complete."
    exit 0
}

trap cleanup SIGINT SIGTERM

check_dependencies() {
    local missing_deps=0
    if ! command -v mediamtx &> /dev/null; then
        print_error "mediamtx command not found. Please ensure it's installed and in your PATH."
        missing_deps=1
    fi
    if ! command -v ffmpeg &> /dev/null; then
        print_error "ffmpeg command not found. Please install ffmpeg (e.g., sudo apt install ffmpeg)."
        missing_deps=1
    fi
    if [ "$SOURCE_TYPE" == "camera" ] && ! command -v v4l2-ctl &> /dev/null; then
        print_warning "v4l2-ctl command not found. Camera listing might be basic."
        print_warning "For better camera detection, please install v4l-utils (e.g., sudo apt install v4l-utils)."
        # We can still try ffmpeg's listing, so not a fatal error for missing_deps here.
    fi
    if [ "$missing_deps" -eq 1 ]; then
        exit 1
    fi
}

get_local_ip() {
    local ip_addr
    ip_addr=$(hostname -I | awk '{print $1}')
    if [ -z "$ip_addr" ]; then
        print_warning "Could not automatically determine local IP address."
        echo "127.0.0.1" # Fallback
    else
        echo "$ip_addr"
    fi
}

prepare_mediamtx_config() {
    if [ ! -f "$MEDIAMTX_CONFIG_FILE" ]; then
        print_info "Configuration file '$MEDIAMTX_CONFIG_FILE' not found in current directory."
        print_info "Creating a default minimal '$MEDIAMTX_CONFIG_FILE' to allow publishing..."
        cat > "$MEDIAMTX_CONFIG_FILE" << EOF
# This is a minimal mediamtx.yml configuration file.
# It allows publishing and reading from any path without authentication.

paths:
  all: {} # Auto-generated by script
EOF
        if [ $? -eq 0 ]; then
            print_info "Default '$MEDIAMTX_CONFIG_FILE' created successfully."
            created_default_config=true
        else
            print_error "Could not create default '$MEDIAMTX_CONFIG_FILE'. Please create it manually with content:\npaths:\n  all: {}"
            exit 1
        fi
    else
        print_info "Using existing '$MEDIAMTX_CONFIG_FILE' found in current directory."
    fi
}

start_mediamtx() {
    print_info "Starting mediamtx..."
    mediamtx &
    mediamtx_pid=$!
    sleep 3 # Give mediamtx time to initialize
    if ! ps -p "$mediamtx_pid" > /dev/null; then
        print_error "mediamtx failed to start. Check output above for errors."
        mediamtx_pid=""
        cleanup
    fi
    print_info "mediamtx started with PID: $mediamtx_pid"
}

start_ffmpeg_stream() {
    local ffmpeg_cmd_string="$1"
    print_info "Starting ffmpeg with command:"
    echo "$ffmpeg_cmd_string" # Show the command for debugging

    # Execute the command string. Using eval can be risky if the command string isn't carefully constructed.
    # However, for this specific use case where we build it internally, it's practical.
    eval "$ffmpeg_cmd_string" &
    ffmpeg_pid=$!
    sleep 2 # Give ffmpeg time to connect

    if ! ps -p "$ffmpeg_pid" > /dev/null; then
        print_error "ffmpeg failed to start or exited prematurely."
        print_error "Check video/camera compatibility, mediamtx status, and ffmpeg logs if loglevel is not 'error'."
        ffmpeg_pid=""
        cleanup
    fi
    print_info "ffmpeg started with PID: $ffmpeg_pid, publishing to mediamtx."
}

list_cameras_v4l2ctl() {
    print_info "Detecting cameras using v4l2-ctl..."
    local devices_output
    devices_output=$(v4l2-ctl --list-devices)
    if [ -z "$devices_output" ]; then
        print_warning "No cameras found by v4l2-ctl."
        return 1
    fi

    echo "Available video devices (from v4l2-ctl):"
    # Parse and display devices
    awk '
        /^[a-zA-Z0-9]/ { if (current_cam) print ""; current_cam=$0; print current_cam }
        /^\t\// { if (current_cam) print $0 }
    ' <<< "$devices_output"

    # Extract /dev/videoX paths for selection
    mapfile -t camera_paths < <(grep -oP '/dev/video[0-9]+' <<< "$devices_output" | sort -u)

    if [ ${#camera_paths[@]} -eq 0 ]; then
        print_warning "No /dev/videoX devices found by v4l2-ctl parsing."
        return 1
    fi

    echo ""
    PS3="Select a camera device: "
    select selected_cam_path in "${camera_paths[@]}"; do
        if [[ -n "$selected_cam_path" ]]; then
            INPUT_PATH="$selected_cam_path"
            break
        else
            print_error "Invalid selection. Please try again."
        fi
    done
    return 0
}

list_cameras_ffmpeg() {
    print_info "Detecting cameras using ffmpeg (basic listing)..."
    # This is a very basic way; ffmpeg's output here isn't as structured for parsing as v4l2-ctl
    # It often lists devices like /dev/video0, /dev/video1 etc. directly if they exist.
    # For a more robust ffmpeg-based listing, one might need to parse `ffmpeg -f v4l2 -list_devices true -i dummy`
    # which is more involved. This is a placeholder for a simpler approach.
    local i=0
    local found_devices=()
    while [ -e "/dev/video$i" ]; do
        found_devices+=("/dev/video$i")
        ((i++))
    done

    if [ ${#found_devices[@]} -eq 0 ]; then
        print_warning "No /dev/videoX devices found by simple check."
        print_error "Cannot detect cameras. Ensure they are connected and you have permissions (e.g., member of 'video' group)."
        return 1
    fi

    echo "Available video devices (basic check):"
    for dev in "${found_devices[@]}"; do
        echo "$dev"
    done
    echo ""
    PS3="Select a camera device: "
    select selected_cam_path in "${found_devices[@]}"; do
        if [[ -n "$selected_cam_path" ]]; then
            INPUT_PATH="$selected_cam_path"
            break
        else
            print_error "Invalid selection. Please try again."
        fi
    done
    return 0
}


display_help() {
    echo "Usage: $0 [options]"
    echo ""
    echo "Options:"
    echo "  -s <type>      Source type: 'file' or 'camera'."
    echo "  -i <input>     Input: Path to video file, or camera device (e.g., /dev/video0)."
    echo "  -n <name>      Stream name for RTSP (default: derived from filename or 'camerastream')."
    echo "  -r <res>       Camera resolution (e.g., '640x480', '1280x720'). Default: $DEFAULT_CAMERA_RESOLUTION."
    echo "  -f <fps>       Camera framerate (e.g., '15', '30'). Default: $DEFAULT_CAMERA_FRAMERATE."
    echo "  -h             Display this help message."
    echo ""
    echo "Examples:"
    echo "  $0 -s file -i myvideo.mp4 -n myvideostream"
    echo "  $0 -s camera -i /dev/video0 -n webcam1 -r 1280x720 -f 30"
    echo "  $0 (interactive mode)"
    exit 0
}

# --- Main Logic ---

# Parse command-line options
while getopts "s:i:n:r:f:h" opt; do
    case $opt in
        s) SOURCE_TYPE="$OPTARG" ;;
        i) INPUT_PATH="$OPTARG" ;;
        n) STREAM_NAME="$OPTARG" ;;
        r) CAMERA_RESOLUTION="$OPTARG" ;;
        f) CAMERA_FRAMERATE="$OPTARG" ;;
        h) display_help ;;
        \?) print_error "Invalid option: -$OPTARG" >&2; display_help ;;
    esac
done

# Interactive mode if source type not provided via arguments
if [ -z "$SOURCE_TYPE" ]; then
    echo "Choose streaming source:"
    select src_choice in "Video File" "Camera" "Exit"; do
        case $src_choice in
            "Video File") SOURCE_TYPE="file"; break ;;
            "Camera") SOURCE_TYPE="camera"; break ;;
            "Exit") exit 0 ;;
            *) print_error "Invalid choice. Please select 1, 2, or 3." ;;
        esac
    done
fi

check_dependencies # Check basic deps first, then camera-specific if needed

if [ "$SOURCE_TYPE" == "file" ]; then
    if [ -z "$INPUT_PATH" ]; then
        read -r -p "Enter the full path to the video file: " INPUT_PATH
    fi
    if [ ! -f "$INPUT_PATH" ]; then
        print_error "Video file '$INPUT_PATH' not found."
        exit 1
    fi
    if [ -z "$STREAM_NAME" ]; then
        STREAM_NAME=$(basename "$INPUT_PATH" | sed 's/\.[^.]*$//' | tr ' ' '_' | tr -cd '[:alnum:]_-')
        [ -z "$STREAM_NAME" ] && STREAM_NAME="$DEFAULT_STREAM_NAME" # Fallback if basename is weird
    fi
    ffmpeg_input_options="-re -stream_loop -1 -i \"$INPUT_PATH\""
    ffmpeg_codec_options="-c copy"

elif [ "$SOURCE_TYPE" == "camera" ]; then
    if [ -z "$INPUT_PATH" ]; then
        if command -v v4l2-ctl &> /dev/null; then
            list_cameras_v4l2ctl || { print_error "Failed to select camera using v4l2-ctl."; exit 1; }
        else
            list_cameras_ffmpeg || { print_error "Failed to select camera using ffmpeg listing."; exit 1; }
        fi
    elif [ ! -e "$INPUT_PATH" ]; then
        print_error "Camera device '$INPUT_PATH' not found."
        exit 1
    fi

    if [ -z "$STREAM_NAME" ]; then
        STREAM_NAME="camerastream_$(basename "$INPUT_PATH")"
    fi
    if [ -z "$CAMERA_RESOLUTION" ]; then
        read -r -p "Enter camera resolution (e.g., $DEFAULT_CAMERA_RESOLUTION, or press Enter for default): " res_input
        CAMERA_RESOLUTION="${res_input:-$DEFAULT_CAMERA_RESOLUTION}"
    fi
    if [ -z "$CAMERA_FRAMERATE" ]; then
        read -r -p "Enter camera framerate (e.g., $DEFAULT_CAMERA_FRAMERATE, or press Enter for default): " fps_input
        CAMERA_FRAMERATE="${fps_input:-$DEFAULT_CAMERA_FRAMERATE}"
    fi

    # Basic ffmpeg options for V4L2 camera.
    # For audio, you might add: -f alsa -i hw:0 (or another audio device)
    # Ensure the camera supports the requested format/resolution/framerate.
    ffmpeg_input_options="-f v4l2 -input_format mjpeg -framerate $CAMERA_FRAMERATE -video_size $CAMERA_RESOLUTION -i \"$INPUT_PATH\""
    # Transcoding is usually necessary for cameras
    ffmpeg_codec_options="-c:v libx264 -preset ultrafast -b:v 2000k -pix_fmt yuv420p" # -c:a aac -b:a 128k (if audio input is added)
    print_info "Using camera settings: Device=$INPUT_PATH, Resolution=$CAMERA_RESOLUTION, Framerate=$CAMERA_FRAMERATE"

else
    print_error "Invalid source type '$SOURCE_TYPE'. Use 'file' or 'camera'."
    display_help
fi

print_info "Selected source: $SOURCE_TYPE"
print_info "Input: $INPUT_PATH"
print_info "Stream Name: $STREAM_NAME"

prepare_mediamtx_config
start_mediamtx

FFMPEG_COMMAND="ffmpeg $ffmpeg_input_options \\
    $ffmpeg_codec_options \\
    -f rtsp -rtsp_transport tcp \\
    \"rtsp://127.0.0.1:$MEDIAMTX_RTSP_PORT/$STREAM_NAME\" \\
    -loglevel \"$FFMPEG_LOG_LEVEL\""

start_ffmpeg_stream "$FFMPEG_COMMAND"

LOCAL_IP=$(get_local_ip)
echo ""
echo "--------------------------------------------------------------------"
echo "Video stream '$STREAM_NAME' should now be accessible at:"
if [ "$LOCAL_IP" != "127.0.0.1" ]; then
    echo "  rtsp://$LOCAL_IP:$MEDIAMTX_RTSP_PORT/$STREAM_NAME"
fi
echo "  rtsp://127.0.0.1:$MEDIAMTX_RTSP_PORT/$STREAM_NAME (on this machine)"
echo "--------------------------------------------------------------------"
echo ""
echo "Press Ctrl+C to stop streaming and shut down."

# Wait for either process to exit; if one exits, trigger cleanup.
wait -n "$mediamtx_pid" "$ffmpeg_pid"
print_info "One of the streaming processes has exited."
cleanup


